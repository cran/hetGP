% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/update_hetGP.R
\name{update.homGP}
\alias{update.homGP}
\title{Fast \code{homGP}-update}
\usage{
\method{update}{homGP}(object, Xnew, Znew = NULL, lower = NULL,
  upper = NULL, noiseControl = NULL, known = NULL, maxit = 100, ...)
}
\arguments{
\item{object}{initial model of class \code{homGP}}

\item{Xnew}{matrix of new design locations; \code{ncol(Xnew)} must match the input dimension encoded in object}

\item{Znew}{vector new observations at those new design locations, of length \code{nrow(X)}. \code{NA}s can be passed, see Details}

\item{lower, upper, noiseControl, known}{optional bounds for MLE optimization, see \code{\link[hetGP]{mleHomGP}}.
If not provided, they are extracted from the existing model}

\item{maxit}{maximum number of iterations for the internal L-BFGS-B optimization method; see \code{\link{optim}} for more details}

\item{...}{no other argument for this method.}
}
\description{
Update existing \code{homGP} model with new observations
}
\details{
In case hyperparameters need not be updated, \code{maxit} can be set to \code{0}. 
In this case it is possible to pass \code{NA}s in \code{Znew}, then the model can still be used to provide updated variance predictions.
}
\examples{
\dontrun{
##------------------------------------------------------------
## Example : Sequential Homoskedastic GP modeling 
##------------------------------------------------------------
set.seed(42)

## Spatially varying noise function
noisefun <- function(x, coef = 1){
  return(coef * (0.05 + sqrt(abs(x)*20/(2*pi))/10))
}

nvar <- 1
n <- 10
X <- matrix(seq(0, 2 * pi, length=n), ncol = 1)
mult <- sample(1:10, n)
X <- rep(X, mult)
Z <- sin(X) + rnorm(length(X), sd = noisefun(X))

testpoints <- matrix(seq(0, 2*pi, length = 10*n), ncol = 1)
model <- model_init <- mleHomGP(X = X, Z = Z,
                                lower = rep(0.1, nvar), upper = rep(50, nvar))
preds <- predict(x = testpoints, object = model_init) 
plot(X, Z)
lines(testpoints, preds$mean, col = "red")


nsteps <- 10
for(i in 1:nsteps){
  newIds <- sort(sample(1:(10*n), 10))
  
  newX <- testpoints[newIds, drop = FALSE] 
  newZ <- sin(newX) + rnorm(length(newX), sd = noisefun(newX))
  points(newX, newZ, col = "blue", pch = 20)
  model <- update(object = model, newX, newZ)
  X <- c(X, newX)
  Z <- c(Z, newZ)
  plot(X, Z)
  print(model$nit_opt)
}
preds_fin <- predict(x = testpoints, object = model) 
lines(testpoints, preds_fin$mean, col = "blue")
lines(testpoints, qnorm(0.05, preds_fin$mean, sqrt(preds_fin$sd2)), col = "blue", lty = 2)
lines(testpoints, qnorm(0.95, preds_fin$mean, sqrt(preds_fin$sd2)), col = "blue", lty = 2)
lines(testpoints, qnorm(0.05, preds_fin$mean, sqrt(preds_fin$sd2 + preds_fin$nugs)),
      col = "blue", lty = 3)
lines(testpoints, qnorm(0.95, preds_fin$mean, sqrt(preds_fin$sd2 + preds_fin$nugs)),
      col = "blue", lty = 3)

model_direct <-  mleHomGP(X = X, Z = Z, lower = rep(0.1, nvar), upper = rep(50, nvar))
preds_direct <- predict(x = testpoints, object = model_direct)
print(model_direct$nit_opt)
lines(testpoints, preds_direct$mean, col = "green")
lines(testpoints, qnorm(0.05, preds_direct$mean, sqrt(preds_direct$sd2)), col = "green", lty = 2)
lines(testpoints, qnorm(0.95, preds_direct$mean, sqrt(preds_direct$sd2)), col = "green", lty = 2)
lines(testpoints, qnorm(0.05, preds_direct$mean, sqrt(preds_direct$sd2 + preds_direct$nugs)),
      col = "green", lty = 3)
lines(testpoints, qnorm(0.95, preds_direct$mean, sqrt(preds_direct$sd2 + preds_direct$nugs)),
      col = "green", lty = 3)

lines(testpoints, sin(testpoints), col = "red", lty = 2)

## Compare outputs
summary(model_init)
summary(model)
summary(model_direct)


}
}
